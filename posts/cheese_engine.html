<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing my own chess engine (CCE)</title>
    <link rel="icon" type="image/png" href="../assets/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../assets/favicon-16x16.png" sizes="16x16" />
    <link rel="stylesheet" href="../css/hex.css">
    <link rel="stylesheet" href="../prism/themer-prism-dark.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>
<script src="../prism/prism.js"></script>
<h1># Writing my own chess engine (CCE)<span class="date"> on Monday July 26th, 2021</span></h1>

<h2>## Introduction</h2>
<p>So, my friend <a href="https://github.com/segfaultdev">@segfaultdev</a> and I wrote a chess engine called <a href="https://github.com/cheese-chess/cheese_chess">cheese</a>. Yay. Only problem, we didn't know about the <a href="https://en.wikipedia.org/wiki/Universal_Chess_Interface">UCI</a> protocol or <em>anything</em> about chess programming. Which meant our engine was kinda useless. So, I started out trying to rewrite cheese in C following all the rules, using <a href="https://www.chessprogramming.org/Bitboards">bitboards</a> etc etc.... Until I realised that, I was writing this engine for <em>fun</em>, so why not try to write it in an easy language first, until I master the concepts behind chess programming, then maybe do a rewrite (yes, a rewrite again) in whatever language I want. So, I chose to write cheese V2.0 in python, using the <a href="https://github.com/niklasf/python-chess">python-chess</a> library for move validation and board representation.</p>
<h2>## The AI</h2>
<h3>### Piece Evaluation</h3>
<p>First of all, we need to identify the values of each piece. Personally, I want to have the piece evaluation function achieve these three things:</p>
<ol>
    <li>Try not to trade a minor piece (knight and bishop) for 3 pawns</li>
    <li>Encourage the engine to keep the bishop pair (bishop together strong lol)</li>
    <li>Try not to exchange two minor pieces for a rook and a pawn</li>
</ol>
<p>So, the values of each piece need to help the engine achieve the above three things. We can start with:</p>
<pre><code class="language-py">B > 3*P
N > 3*P
</code></pre>
<p>Next, we can put:</p>
<pre><code class="language-py">B > N
</code></pre>
<p>Combining 1 and 2, we can say that:</p>
<pre><code class="language-py">B > N > 3*P
</code></pre>
<p>For the final condition, we can put something like:</p>
<pre><code class="language-py">B + N = R + 1.5*P</code></pre>
<p>So, an example piece value table that satisfies all of the above is:</p>
<pre><code class="language-py">P = 100
N = 320
B = 330
R = 500
Q = 900
K = 20000
</code></pre>
<p>So the simplest evaluation function will loop over every square of the board, and, if the piece is white, it will add to the value, and if the piece is black, it will subtract. A simple implementation is:</p>
<pre><code class="language-py">import chess

def eval_material(board):
    material = 0
    for square in chess.SQUARES:
        if board.piece_at(square) == chess.PAWN:
            material += 100 if piece.color else material -= 100
        if board.piece_at(square) == chess.KNIGHT:
            material += 320 if piece.color else material -= 320
        if board.piece_at(square) == chess.BISHOP:
            material += 330 if piece.color else material -= 330
        if board.piece_at(square) == chess.ROOK: 
            material += 500 if piece.color else material -= 500
        if board.piece_at(square) == chess.QUEEN: 
            material += 900 if piece.color else material -= 900
        if board.piece_at(square) == chess.KING: 
            material += 20000 if piece.color else material -= 20000
    
    return material 
</code></pre>

<h3>### Searching for moves</h3>
<p>Using our evaluation function, we can start implementing a function that will search for the best move. We will be using the <a href="https://en.wikipedia.org/wiki/Minimax">minimax</a> algorithm. However, because of the exponential nature of the possibilities of chess games, and the limitations by our computing hardware, we can't search <em>all</em> the possible games in time. Therefore, we implement <a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">Alpha-Beta Pruning</a> to speed up the process, which will stop searching deeper into the tree once it finds a bad value. See the below image:</p>
<img src="../assets/alpha-beta-pruning.png">
<p>As you can see, it stops searching deeper when it finds a value that is less than the previous one. (or bigger, depends on whether you are minimizing or maximizing). And, that's all, after implementing this we now have a playable chess engine. Of course there are still enhancements we can implement, like <a href="https://rustic-chess.org/evaluation/psqt.html">piece square tables</a> and <a href="https://www.chessprogramming.org/Opening_Book">openings</a> etc...</p>

<h3>### Playing it on lichess</h3>
<p>I hooked up cheese to <a href="https://github.com/ShailChoksi/lichess-bot">lichess-bot</a>, which uses the UCI protocol to communicate with the lichess API. You can challenge cheese <a href="https://lichess.org/@/Cheese_Chess_Engine">here</a>. You can see a full specification of the UCI protocol <a href="http://wbec-ridderkerk.nl/html/UCIProtocol.html">here</a>. You can see the source code <a href="https://github.com/cheese-chess/cheese_py">here</a>.</p>

<h2>## Resources</h2>
<p>In case you want to build your own chess engine, here are some helpful resources:</p>
<ul>
    <li><a href="https://www.chessprogramming.org/Main_Page">Chess Programming Wiki</a></li>
    <li><a href="https://www.youtube.com/watch?v=l-hh51ncgDI">Algorithms Explained â€“ minimax and alpha-beta pruning</a></li>
    <li><a href="https://github.com/thomasahle/sunfish">Sunfish Source Code</a></li>
</ul>

<p>Until next time, happy coding (:</p>
<a href="../index.html">Go back</a>
</body>
</html>